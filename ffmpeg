# -*- shell-script -*-

in_path ffmpeg || return 0

alias ffprobe='\ffprobe -hide_banner'

ffprobes() {
  local _all _cmd

  while [[ "$1" =~ ^-+[[:alnum:]]+$ ]] ; do
    case "$1" in
#      -a|--all) _all=y;;
      -h|--help) myfunusage "[--help] <files> | [--all] [--play] <dir> [<query>]"; return 0;;
      -p|--play) _cmd="vlc";;
    esac
    shift
  done

  if [[ $# -gt 0 && -d "$1" ]] ; then

    local -a _selected

    eval "_selected=($(find "$1" -type f -print0 | \
                       xargs -r0 file -i | \
                       sed -rn 's~^(.+): +(audio|video)/.*$~\1~p' | \
                       fzf --border none \
                           --list-label " Audio and video files in \"$(realpath "$1")/\" " \
                           --multi \
                           --no-sort \
                           --preview 'echo {}; fzf_preview_hrule; ffprobe -hide_banner {}' \
                           --preview-label " ffprobe output " \
                           --preview-window '60%,~2:wrap' \
                           --print0 \
                           --query "$2" | \
                       xargs -0 -i@ echo '"@"'))"

    [ ${#_selected[@]} -gt 0 ] || return 0

    ${_cmd:-echo} "${_selected[@]}"

  elif [ $# -gt 0 ] ; then

    local _f
    for _f in "$@" ; do

      # files not applicable as ffprobe input are ignored silently
      if file -i "$_f" 2>/dev/null | grep --silent -E '(audio|video)/' ; then

        ffprobe "$_f"

      fi

    done 2>&1 | \
    grep --color=never --extended-regexp '^ *(Input|Duration:|Stream) '

  else

    echo "Missing path argument(s)!" >&2
    false

  fi
}
