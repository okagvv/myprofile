# -*- shell-script -*-

a() {
  alias "$@" | m -p "bash aliases"
}
complete -A alias a

abbr_pwd() {
  sed -E -e "s:^${HOME}:~:;s:^.+((/[^/]+){3})$:…\1:;s:([^/]{4})[^/]{4,}([^/]{4})/:\1…\2/:g" <<< "$PWD"
}

cleanup_path() {
  export PATH=$(printf %s "$PATH" | awk -v RS=: -v ORS=: '!arr[$0]++' | sed -r 's/:://g;s/:$//;s/^://')
}

e() {
  # list current environment without $PS1 (shell prompt may embed escape sequences distorting output)
  printenv -0 | grep -zvE "^PS1=" | sort -z | tr '\000' '\n' | m -p "environment variables"
}



find_last() {
  find ${1:-.} -type f -printf "%M~%TF %TT~%u:%g~%s~%P\n" | \
  sed -r 's/(:[0-9]{2})\.[0-9]+~/\1~/' | \
  column -t -s~ -o'  ' | \
  sort -k2dr -k3dr
}
complete -A directory find_last

h() {
  local _cnt _color
  if [[ "$1" =~ ^-(a|-all)$ ]] ; then
    shift
    _cnt=$HISTSIZE
  else
    _cnt="42"
  fi
  [ $# -gt 0 ] && _color=auto || _color=never
  history | grep --color=never -E "${1:-.*}" | tail -$_cnt | grep --colour=$_color -E "${1:-.*}"
}

history_cleanup() {
  # remove sensible a/o undesired entries from bash history
  # args: "$remove_regexp" .. [-- "$keep_regexp" ..]

  if [ -n "$HISTFILE" ] ; then

    local _pattern _histfile _keep _drop
    _drop="(${FUNCNAME[0]}"

    for _pattern in "$@" ; do

      if [[ "$_pattern" == "--" ]] ; then
        _keep="(~§~§~"
      elif [ -n "$_keep" ] ; then
        _keep+="|$_pattern"
      else
        _drop+="|$_pattern"
      fi

    done

    _drop+=")"
    [ -z "$_keep" ] && _keep="~§~§~" || _keep+=")"

    _histfile="$HISTFILE"

    eval "$(history |
            sed -rn '/'"$_keep"'/d;s/^ *([0-9]+) .*'"$_drop"'.*/\1/ip' |
            sort --numeric-sort --reverse |
            xargs --no-run-if-empty --replace=@ echo history -d @)"

    # Work-around for "history -w" failing to update history file mounted into a container.
    HISTFILE="$(mktemp --suffix=.history --tmpdir bash_XXXXXX)"
    history -w
    cat "$HISTFILE" >"$_histfile"
    HISTFILE="$_histfile"

    history -s : history_cleanup
    sleep 1

  fi

  true
}

lm() {
  l --color=always "$@" |& m -p lm
}

lmt() {
  l --color=always --sort=time "$@" |& m -p lmt
}
complete -o bashdefault -o default l lmt lm

m() {
  local _prompt

  while [ $# -gt 0 ] ; do
    case "$1" in
           -h|--help) fn-usage "[-p|--prompt \"text\"]"; return 0;;
      -[pP]|--prompt) _prompt="$2"; shift 2;;
                   *) break;;
    esac
  done

  TERM=xterm less --hilite-search \
                  --ignore-case \
                  --mouse \
                  --no-histdups \
                  --no-init \
                  --no-vbell \
                  --prompt "$_prompt ?f%f.?lt line %lt?L/%L. .?e(END)" \
                  --quit-if-one-screen \
                  --squeeze-blank-lines \
                  --status-line \
                  --tilde \
                  --use-color \
                  "$@"
}
complete -o default m

myjournalctl() {
  journalctl --no-hostname --output=short-iso "$@"
}

if in-path keepassxc-cli ; then
  
  mypassgen() {
    #CAUTION: Vault (root) token must not contain dots!
    keepassxc-cli generate --length "${1:-14}" --lower --upper --numeric --special --exclude-similar \
                           --every-group --exclude "({[<>]})&*?'\\\`\$\!\"."
  }
  
fi

parse_git_branch() {
  git branch 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/ (\1)/'
}

if in-path pdfgrep ; then
  
  pdfgrep() {
    /usr/bin/pdfgrep "$@" | sed -r 's/ +/ /g' | m
  }

fi

if in-path rsync ; then
  
  rsyncp() {
    local -a _opts
    _opts=(--archive --backup --hard-links --human-readable --itemize-changes --progress --whole-file)

    while [ $# -gt 1 ] ; do
      case "$1" in
          -h|--help) fn-usage "[--dry] [--remove] <source-dir>/? <target-dir>"; return 0;;
           -d|--dry) _opts+=(--dry-run --verbose);;
        -r|--remove) _opts+=(--delete-delay);;
                  *) break;;
      esac
      shift
    done

    if [[ $# -ge 2 && -d "${@: -2:1}" && -d "${@: -1}" ]] ; then

      local _dir
      for _dir in "${@: -2}" ; do
        if [[ "$(stat -f -c %T "$_dir" 2>/dev/null)" =~ ^(nfs|exfat|fuseblk)$ ]] ; then
          _opts+=(--no-perms --no-owner --no-group)
          break
        fi
      done

      ionice -c2 -n7 rsync "${_opts[@]}" "$@"

    else

      fn-error "Source (${@: -2:1}) a/o target (${@: -1}) directories do not exist!"

    fi
  }

fi

uriencode() {
  gojq -nr --arg v "$1" '$v|@uri';
}

[[ "$(id -u)" == "0" ]] || return 0

# ------------ functions requiring root permission ------------

juser() {
  if [ $# -gt 0 ] ; then
    local _uid="$(id -u "$1")"
    shift
    myjournalctl --pager-end _UID="$_uid" "$@"
  else
    fn-usage "user [journalct options]"
  fi
}
complete -A user -o default juser

mysu() {
    # Start command-line via su for user derived from path owner of last argument.
    # Preserves white spaces in arguments.
    if [ $# -ge 2 ] ; then
      su $(stat -c %U "${*: -1}") -c "$(printf "'%s' " "${@}")"
    else
      fn-usage "command [options|args] file"
    fi
}
complete -A command -o default mysu

oom_killed() {
  myjournalctl --dmesg --since today "$@" | grep -i 'killed process'
}
