# -*- shell-script -*-
# Bash functions applicable in interactive login shells and scripts.

in-path() {
  type -fp "$1" >/dev/null
}

is-fn() {
  declare -F "$1" >/dev/null
}

mycomplete() {
  # ignore complete in scripts
  [ -z "$PS1" ] || complete "$@"
}

abbr-pwd() {
  sed -E -e "s:^${HOME}:~:;s:^.+((/[^/]+){3})$:…\1:;s:([^/]{4})[^/]{4,}([^/]{4})/:\1…\2/:g" <<< "$PWD"
}

cleanup-path() {
  export PATH=$(printf %s "$PATH" | awk -v RS=: -v ORS=: '!arr[$0]++' | sed -r 's/:://g;s/:$//;s/^://')
}

find-last() {
  find ${1:-.} -type f -printf "%M~%TF %TT~%u:%g~%s~%P\n" | \
  sed -r 's/(:[0-9]{2})\.[0-9]+~/\1~/' | \
  column -t -s~ -o'  ' | \
  sort -k2dr -k3dr
}
mycomplete -A directory find-last


script=
fn-usage() {
  echo -e "\e[34mUsage: ${script:-${FUNCNAME[1]}} $1\e[0m"
  return 2
}

fn-error() {
  echo -e "\e[31m${script:-${FUNCNAME[1]}}: $1\e[0m" >&2
  return 1
}

fn-abort() {
  if [ -n "$PS1" ] ; then

    fn-error "$1"
    exit 1

  else

    # work-around to abort (nested) functions
    local _origin="${script:-${FUNCNAME[1]}}"
    eval "_fn-abort() { unset $_origin; : \"\${$_origin:?\$1}\"; }"
    _fn-abort "$1"

  fi
}

fn_xtrace=
fn-xtrace() {
  # Enable xtrace until return from calling function.
  fn_xtrace="${FUNCNAME[1]}"
  [ -n "$fn_xtrace" ] || return 0

  trap 'if [[ "$FUNCNAME" == "$fn_xtrace" ]] ; then set +x; trap - RETURN; echo "-===- Stopped trace for $fn_xtrace() -===-"; fn_xtrace=; fi' RETURN

  echo "-===- Start xtrace for $fn_xtrace() -===-"
  set -x
}

myjournalctl() {
  journalctl --no-hostname --output=short-iso "$@"
}

if in-path keepassxc-cli ; then

  mypassgen() {
    #CAUTION: Vault (root) token must not contain dots!
    keepassxc-cli generate --length "${1:-14}" --lower --upper --numeric --special --exclude-similar \
                           --every-group --exclude "({[<>]})&*?'\\\`\$\!\"."
  }

fi

uriencode() {
  gojq -nr --arg v "$1" '$v|@uri';
}
